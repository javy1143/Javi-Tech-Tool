Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Ensure PSWindowsUpdate is present and import it globally
try {
     if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
         Write-Host "PSWindowsUpdate module not found. Please install it manually or restore Ensure-PSWindowsUpdate function." -ForegroundColor Yellow
         # Optionally add install logic back here if desired
         throw "PSWindowsUpdate module missing."
     }
     Import-Module PSWindowsUpdate -Force -ErrorAction Stop
     Write-Host "PSWindowsUpdate imported globally."
} catch {
     [System.Windows.Forms.MessageBox]::Show("Failed to import PSWindowsUpdate globally: $_", "Module Error", 'OK', 'Error')
     # Consider exiting the script if the module is essential and fails to load
     # exit
}

# ============================================
# Define Helper: Ensure PSWindowsUpdate Module
# ============================================
function Ensure-PSWindowsUpdate {
    if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
        Write-Host "Installing PSWindowsUpdate module..."
        try {
            Install-PackageProvider -Name NuGet -Force -ErrorAction Stop
            Install-Module -Name PSWindowsUpdate -Force -ErrorAction Stop
            Import-Module PSWindowsUpdate -Force -ErrorAction Stop
        } catch {
            [System.Windows.Forms.MessageBox]::Show("Failed to install PSWindowsUpdate: $_", "Error", 'OK', 'Error')
            throw $_
        }
    } else {
        Import-Module PSWindowsUpdate -Force -ErrorAction Stop
    }
}

# ============================================
# Create Main Form
# ============================================
$form = New-Object System.Windows.Forms.Form
$form.Text = "PC Optimizer"
$form.Size = New-Object System.Drawing.Size(1000, 700)
$form.StartPosition = "CenterScreen"
$form.MaximizeBox = $false

$tabControl = New-Object System.Windows.Forms.TabControl
$tabControl.Dock = "Fill"

# ============================================
# SYSTEM INFO TAB (centered and spaced layout, themed colors)
# ============================================
$tabSystemInfo = New-Object System.Windows.Forms.TabPage
$tabSystemInfo.Text = "System Info"
$tabSystemInfo.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

# Add SwiftTune Logo to System Info Tab (use provided path)
$logoPath = "C:\Powershell\PowershellScripts\SwiftTune\SwiftTuneLogo.png"
if (Test-Path $logoPath) {
    $logoImage = [System.Drawing.Image]::FromFile($logoPath)

    $logoBox = New-Object System.Windows.Forms.PictureBox
    $logoBox.Image = $logoImage
    $logoBox.SizeMode = 'Zoom'
    $logoBox.Size = New-Object System.Drawing.Size(150, 150)
    $logoBox.Location = New-Object System.Drawing.Point(425, 10)  # Centered horizontally near top

    $tabSystemInfo.Controls.Add($logoBox)
}

# Collect system info
$cpu = (Get-CimInstance Win32_Processor).Name
$ram = [math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)
$os = (Get-CimInstance Win32_OperatingSystem).Caption
$osVer = (Get-CimInstance Win32_OperatingSystem).Version
$uptime = ((Get-CimInstance Win32_OperatingSystem).LastBootUpTime).ToLocalTime()
$diskC = Get-CimInstance Win32_LogicalDisk -Filter "DeviceID='C:'"
$diskTotal = [math]::Round($diskC.Size / 1GB, 2)
$diskFree = [math]::Round($diskC.FreeSpace / 1GB, 2)

# Create a multiline label for system info (centered and spaced)
$sysInfoLabel = New-Object System.Windows.Forms.Label
$sysInfoLabel.Location = New-Object System.Drawing.Point(250, 180)
$sysInfoLabel.Size = New-Object System.Drawing.Size(500, 400)
$sysInfoLabel.Font = New-Object System.Drawing.Font("Segoe UI", 12)
$sysInfoLabel.TextAlign = 'MiddleCenter'
$sysInfoLabel.ForeColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$sysInfoLabel.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$sysInfoLabel.Text = "
────────────────────────────────────────────
   CPU:
   $cpu

   RAM:
   $ram GB

   OS:
   $os ($osVer)

   Last Boot:
   $uptime

   Disk (C:)
   Total: $diskTotal GB
   Free:  $diskFree GB
────────────────────────────────────────────
"
$tabSystemInfo.Controls.Add($sysInfoLabel)
# Apply the color palette to the main form
$form.BackColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$tabControl.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

# ============================================
# PERFORMANCE TWEAKS TAB (full script with color palette)
# ============================================
$tabPerformance = New-Object System.Windows.Forms.TabPage
$tabPerformance.Text = "Performance Tweaks"
$tabPerformance.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

$groupVisual = New-Object System.Windows.Forms.GroupBox
$groupVisual.Text = "Visual Tweaks"
$groupVisual.ForeColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$groupVisual.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$groupVisual.Location = New-Object System.Drawing.Point(20, 20)
$groupVisual.Size = New-Object System.Drawing.Size(450, 300)
$tabPerformance.Controls.Add($groupVisual)

$groupSystem = New-Object System.Windows.Forms.GroupBox
$groupSystem.Text = "System Tweaks"
$groupSystem.ForeColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$groupSystem.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$groupSystem.Location = New-Object System.Drawing.Point(500, 20)
$groupSystem.Size = New-Object System.Drawing.Size(450, 400)
$tabPerformance.Controls.Add($groupSystem)

$visualTweaks = @(
    @{ Text = "Set Visual Effects to Best Performance"; Variable = 'checkVisuals' },
    @{ Text = "Disable Transparency Effects"; Variable = 'checkTransparency' },
    @{ Text = "Disable Window Animations"; Variable = 'checkAnimations' },
    @{ Text = "Speed Up Menu Show Delay"; Variable = 'checkMenuDelay' }
)

$systemTweaks = @(
    @{ Text = "Set Power Plan to High Performance"; Variable = 'checkPower' },
    @{ Text = "Disable SysMain (Superfetch)"; Variable = 'checkSysMain' },
    @{ Text = "Disable Search Indexing (if SSD)"; Variable = 'checkIndexing' },
    @{ Text = "Set Processor Scheduling to Favor Programs"; Variable = 'checkProcessor' },
    @{ Text = "Clear Temporary Files"; Variable = 'checkTemp' },
    @{ Text = "Disable Windows Tips and Suggestions"; Variable = 'checkTips' },
    @{ Text = "Clear Edge Browser Cache"; Variable = 'checkEdgeCache' },
    @{ Text = "Clear Chrome Browser Cache"; Variable = 'checkChromeCache' }
)

$y = 30
foreach ($item in $visualTweaks) {
    $chk = New-Object System.Windows.Forms.CheckBox
    $chk.Text = $item.Text
    $chk.ForeColor = [System.Drawing.Color]::FromArgb(22, 153, 118)
    $chk.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
    $chk.Location = New-Object System.Drawing.Point(10, $y)
    $chk.AutoSize = $true
    Set-Variable -Name $item.Variable -Value $chk -Scope Script
    $groupVisual.Controls.Add($chk)
    $y += 30
}

$y = 30
foreach ($item in $systemTweaks) {
    $chk = New-Object System.Windows.Forms.CheckBox
    $chk.Text = $item.Text
    $chk.ForeColor = [System.Drawing.Color]::FromArgb(22, 153, 118)
    $chk.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
    $chk.Location = New-Object System.Drawing.Point(10, $y)
    $chk.AutoSize = $true
    Set-Variable -Name $item.Variable -Value $chk -Scope Script
    $groupSystem.Controls.Add($chk)
    $y += 30
}

$applyButton = New-Object System.Windows.Forms.Button
$applyButton.Text = "Apply Selected Tweaks"
$applyButton.Size = New-Object System.Drawing.Size(200, 40)
$applyButton.Location = New-Object System.Drawing.Point(20, 350)
$applyButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$applyButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$applyButton.Add_Click({
    $progressBar.Style = 'Marquee'
    $statusLabel.Text = "Applying selected performance tweaks..."
    $form.Refresh()
    try {
        if ($checkVisuals.Checked) { Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\VisualEffects" -Name VisualFXSetting -Value 2 }
        if ($checkTransparency.Checked) { Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize" -Name EnableTransparency -Value 0 }
        if ($checkAnimations.Checked) { Set-ItemProperty -Path "HKCU:\Control Panel\Desktop\WindowMetrics" -Name MinAnimate -Value 0 }
        if ($checkMenuDelay.Checked) { Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name MenuShowDelay -Value 100 }
        if ($checkPower.Checked) {
            $highPerfGuid = (powercfg /L | Select-String "High performance" | ForEach-Object { ($_ -split '\s+')[3] })
            if ($highPerfGuid) { powercfg /S $highPerfGuid }
        }
        if ($checkSysMain.Checked) {
            Stop-Service -Name "SysMain" -ErrorAction SilentlyContinue
            Set-Service -Name "SysMain" -StartupType Disabled -ErrorAction SilentlyContinue
        }
        if ($checkIndexing.Checked) {
            $driveC = Get-PhysicalDisk | Where-Object { $_.DeviceID -eq 0 }
            if ($driveC.MediaType -eq 'SSD') {
                Stop-Service -Name "WSearch" -ErrorAction SilentlyContinue
                Set-Service -Name "WSearch" -StartupType Disabled -ErrorAction SilentlyContinue
            }
        }
        if ($checkProcessor.Checked) { Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\PriorityControl" -Name Win32PrioritySeparation -Value 26 }
        if ($checkTemp.Checked) { Get-ChildItem -Path $env:TEMP -Recurse -Force | Remove-Item -Recurse -Force }
        if ($checkTips.Checked) { Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\ContentDeliveryManager" -Name SubscribedContent-338388Enabled -Value 0 }
        if ($checkEdgeCache.Checked) {
            $edgeCachePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cache"
            if (Test-Path $edgeCachePath) { Get-ChildItem -Path $edgeCachePath -Recurse -Force | Remove-Item -Recurse -Force }
        }
        if ($checkChromeCache.Checked) {
            $chromeCachePath = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cache"
            if (Test-Path $chromeCachePath) { Get-ChildItem -Path $chromeCachePath -Recurse -Force | Remove-Item -Recurse -Force }
        }
        [System.Windows.Forms.MessageBox]::Show("Selected performance tweaks applied!", "Success", 'OK', 'Information')
        $statusLabel.Text = "Performance tweaks applied."
    } catch {
        $statusLabel.Text = "Error applying performance tweaks."
        [System.Windows.Forms.MessageBox]::Show("An error occurred: $_", "Error", 'OK', 'Error')
    } finally {
        $progressBar.Style = 'Blocks'
    }
})
$tabPerformance.Controls.Add($applyButton)


# ============================================
# STARTUP MANAGER TAB (with color palette)
# ============================================
$tabStartup = New-Object System.Windows.Forms.TabPage
$tabStartup.Text = "Startup Manager"
$tabStartup.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

$startupLabel = New-Object System.Windows.Forms.Label
$startupLabel.Text = "Select startup items to disable or enable:"
$startupLabel.Location = New-Object System.Drawing.Point(20, 10)
$startupLabel.Size = New-Object System.Drawing.Size(500, 20)
$startupLabel.ForeColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$startupLabel.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$tabStartup.Controls.Add($startupLabel)

$startupListBox = New-Object System.Windows.Forms.ListBox
$startupListBox.Location = New-Object System.Drawing.Point(20, 40)
$startupListBox.Size = New-Object System.Drawing.Size(740, 400)
$startupListBox.SelectionMode = "MultiExtended"
$startupListBox.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$startupListBox.ForeColor = [System.Drawing.Color]::FromArgb(22, 153, 118)
$tabStartup.Controls.Add($startupListBox)

function Load-StartupItems {
    $startupListBox.Items.Clear()
    $userRun = Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -ErrorAction SilentlyContinue
    if ($userRun) {
        $userRun.PSObject.Properties | ForEach-Object {
            if ($_.Name -and $_.Value) {
                $startupListBox.Items.Add("User | $($_.Name) | $($_.Value)") | Out-Null
            }
        }
    }
    $machineRun = Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -ErrorAction SilentlyContinue
    if ($machineRun) {
        $machineRun.PSObject.Properties | ForEach-Object {
            if ($_.Name -and $_.Value) {
                $startupListBox.Items.Add("Machine | $($_.Name) | $($_.Value)") | Out-Null
            }
        }
    }
    $startupFolder = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
    if (Test-Path $startupFolder) {
        Get-ChildItem $startupFolder -Filter *.lnk | ForEach-Object {
            $startupListBox.Items.Add("Folder | $($_.Name) | $($_.FullName)") | Out-Null
        }
    }
}
Load-StartupItems

$disableButton = New-Object System.Windows.Forms.Button
$disableButton.Text = "Disable Selected"
$disableButton.Size = New-Object System.Drawing.Size(180, 30)
$disableButton.Location = New-Object System.Drawing.Point(20, 550)
$disableButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$disableButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$disableButton.Add_Click({
    foreach ($item in $startupListBox.SelectedItems) {
        $parts = $item -split '\|'
        $scope = $parts[0].Trim()
        $name = $parts[1].Trim()
        if ($scope -eq "User") { Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name $name -ErrorAction SilentlyContinue }
        elseif ($scope -eq "Machine") { Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -Name $name -ErrorAction SilentlyContinue }
        elseif ($scope -eq "Folder") {
            $file = $parts[2].Trim()
            if (Test-Path $file) { Rename-Item -Path $file -NewName ($file + ".disabled") -ErrorAction SilentlyContinue }
        }
    }
    Load-StartupItems
    [System.Windows.Forms.MessageBox]::Show("Selected items disabled.", "Success", 'OK', 'Information')
})
$tabStartup.Controls.Add($disableButton)

$enableButton = New-Object System.Windows.Forms.Button
$enableButton.Text = "Enable Selected"
$enableButton.Size = New-Object System.Drawing.Size(180, 30)
$enableButton.Location = New-Object System.Drawing.Point(220, 550)
$enableButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$enableButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$enableButton.Add_Click({
    foreach ($item in $startupListBox.SelectedItems) {
        $parts = $item -split '\|'
        $scope = $parts[0].Trim()
        $file = $parts[2].Trim()
        if ($scope -eq "Folder" -and $file.EndsWith(".disabled") -and (Test-Path $file)) {
            $original = $file -replace '\.disabled$', ''
            Rename-Item -Path $file -NewName $original -ErrorAction SilentlyContinue
        }
    }
    Load-StartupItems
    [System.Windows.Forms.MessageBox]::Show("Selected folder items re-enabled.", "Success", 'OK', 'Information')
})
$tabStartup.Controls.Add($enableButton)

$refreshButton = New-Object System.Windows.Forms.Button
$refreshButton.Text = "Refresh List"
$refreshButton.Size = New-Object System.Drawing.Size(150, 30)
$refreshButton.Location = New-Object System.Drawing.Point(420, 550)
$refreshButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$refreshButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$refreshButton.Add_Click({
    $progressBar.Style = 'Marquee'
    $statusLabel.Text = "Refreshing startup list..."
    $form.Refresh()
    try {
        Load-StartupItems
        $statusLabel.Text = "Startup items refreshed."
    } catch {
        $statusLabel.Text = "Error refreshing startup list."
    } finally {
        $progressBar.Style = 'Blocks'
    }
})
$tabStartup.Controls.Add($refreshButton)

# ============================================
# Helper Function for Background Jobs (Modified for Error Handling)
# ============================================
# Define this function earlier in your script if it's not already defined,
# or replace the existing one if it is.
function Invoke-InBackground {
    param (
        [Parameter(Mandatory=$true)]
        [scriptblock]$Script,

        [Parameter(Mandatory=$true)]
        [System.Action]$OnComplete, # Action to run on the main thread after job completes

        [Parameter(Mandatory=$false)]
        [System.Action[string]]$OnError # Action to run on main thread if job fails
    )
    $job = Start-Job -ScriptBlock $Script
    Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
        param($sender, $eventArgs)

        if ($sender.State -in ('Completed', 'Failed', 'Stopped')) {
            # Ensure UI updates happen on the main thread using SynchronizationContext if available,
            # otherwise directly invoke (might cause cross-thread issues in complex GUIs, but often ok here)
            $syncContext = [System.Windows.Forms.Application]::OpenForms[0].Invoke([System.Func[System.Threading.SynchronizationContext]]{
                return [System.Threading.SynchronizationContext]::Current
            })

            # Unregister the event to avoid memory leaks
            Unregister-Event -SourceIdentifier $sender.InstanceId.Guid.ToString()

            # Receive Job data (output and errors)
            $jobData = Receive-Job -Job $sender -Keep # Use -Keep to allow receiving multiple times if needed, though usually once is fine
            $jobErrors = $jobData | Where-Object { $_ -is [System.Management.Automation.ErrorRecord] }
            $jobOutput = $jobData | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }

            # Store results globally (ensure $global:scoped variables are used in the scriptblock if needed)
            # Note: The script block itself should assign to $global:updateResults or similar as before.
            # This example primarily focuses on error handling after completion.

            Remove-Job -Job $sender # Clean up the job object

            # Execute OnComplete or OnError on the main thread
            if ($syncContext) {
                $syncContext.Post({
                    if ($jobErrors) {
                        if ($OnError) {
                            $errorMessages = $jobErrors | ForEach-Object { $_.ToString() }
                            $OnError.Invoke(($errorMessages -join [System.Environment]::NewLine))
                        }
                    } else {
                        # Pass output if needed, though original relies on globals set in $Script
                        $OnComplete.Invoke()
                    }
                }, $null)
            } else {
                # Fallback if no sync context (less safe for complex UI updates)
                 if ($jobErrors) {
                    if ($OnError) {
                        $errorMessages = $jobErrors | ForEach-Object { $_.ToString() }
                        $OnError.Invoke(($errorMessages -join [System.Environment]::NewLine))
                    }
                } else {
                    $OnComplete.Invoke()
                }
            }
        }
    } | Out-Null # Suppress output from Register-ObjectEvent
    # Return the job object if needed, though this example doesn't use it directly after starting
    return $job
}


# ============================================
# WINDOWS UPDATES TAB (Direct Execution - UI WILL FREEZE TEMPORARILY)
# ============================================

$tabUpdates = New-Object System.Windows.Forms.TabPage
$tabUpdates.Text = "Windows Updates"
$tabUpdates.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

$updateLabel = New-Object System.Windows.Forms.Label
$updateLabel.Text = "Select updates to install (requires PSWindowsUpdate module): UI will freeze during check/install."
$updateLabel.Location = New-Object System.Drawing.Point(20, 10)
$updateLabel.Size = New-Object System.Drawing.Size(940, 20) # Wider label
$updateLabel.ForeColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$tabUpdates.Controls.Add($updateLabel)

$updateListBox = New-Object System.Windows.Forms.ListBox
$updateListBox.Location = New-Object System.Drawing.Point(20, 40)
$updateListBox.Size = New-Object System.Drawing.Size(940, 500)
$updateListBox.SelectionMode = "MultiExtended"
$updateListBox.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$updateListBox.ForeColor = [System.Drawing.Color]::FromArgb(22, 153, 118)
$updateListBox.HorizontalScrollbar = $true # Add scrollbar for long titles
$tabUpdates.Controls.Add($updateListBox)

# --- Helper Function to Run Update Actions Directly (Corrected Parameter Type) ---
function Invoke-UpdateAction {
    param(
        [Parameter(Mandatory=$true)]
        [scriptblock]$Action, # CORRECTED TYPE: The core action (Get-WindowsUpdate or Install-WindowsUpdate)
        [Parameter(Mandatory=$true)]
        [string]$StatusStartMessage,
        [Parameter(Mandatory=$true)]
        [string]$StatusSuccessMessage,
        [Parameter(Mandatory=$true)]
        [string]$StatusFailMessage,
        [Parameter(Mandatory=$false)] # Optional parameter to pass to the action
        [object]$ActionParameter
    )

    # Provide immediate feedback and disable controls
    $statusLabel.Text = $StatusStartMessage + " (UI will freeze...)"
    $progressBar.Style = 'Marquee'
    $loadSecurityButton.Enabled = $false
    $loadDriverButton.Enabled = $false
    $installButton.Enabled = $false
    $form.Refresh() # Force UI update before potential freeze

    $result = $null
    $success = $false

    try {
        Write-Host "$(Get-Date -Format 'HH:mm:ss') - Importing PSWindowsUpdate..."
        # Ensure module is imported in the current scope
        Write-Host "$(Get-Date -Format 'HH:mm:ss') - Executing action directly..."

        # Execute the provided action (scriptblock)
        # The call operator '&' works correctly with scriptblocks
        if ($PSBoundParameters.ContainsKey('ActionParameter')) {
             $result = & $Action $ActionParameter # Pass parameter if provided
        } else {
             $result = & $Action # Run action without parameter
        }

        Write-Host "$(Get-Date -Format 'HH:mm:ss') - Action completed directly. Result is null/empty: $([string]::IsNullOrEmpty($result))"
        $statusLabel.Text = $StatusSuccessMessage
        $success = $true
    } catch {
        Write-Host "$(Get-Date -Format 'HH:mm:ss') - Error during direct execution: $($_.Exception.ToString())"
        $statusLabel.Text = $StatusFailMessage
        [System.Windows.Forms.MessageBox]::Show("An error occurred:`n`n$($_.Exception.Message)", "Operation Error", 'OK', 'Error')
        $success = $false
    } finally {
        # Always re-enable controls and reset progress bar
        $progressBar.Style = 'Blocks'
        $loadSecurityButton.Enabled = $true
        $loadDriverButton.Enabled = $true
        $installButton.Enabled = $true
        Write-Host "$(Get-Date -Format 'HH:mm:ss') - UI elements re-enabled."
        $form.Refresh()
    }

    # Return results (or $null/$false on failure) bundled with success status
    return @{ Success = $success; Data = $result }
}

# --- Load Security Updates Button ---
$loadSecurityButton = New-Object System.Windows.Forms.Button
$loadSecurityButton.Text = "Load Security Updates"
$loadSecurityButton.Size = New-Object System.Drawing.Size(180, 30)
$loadSecurityButton.Location = New-Object System.Drawing.Point(20, 550)
$loadSecurityButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$loadSecurityButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$loadSecurityButton.Add_Click({
    $updateListBox.Items.Clear() # Clear list before loading

    $result = Invoke-UpdateAction `
        -Action { Get-WindowsUpdate -Criteria "IsInstalled=0 and Type='Software' and IsHidden=0" -IgnoreUserInput -Verbose } `
        -StatusStartMessage "Loading security updates..." `
        -StatusSuccessMessage "Security updates loaded." `
        -StatusFailMessage "Error loading security updates."

    if ($result.Success -and $result.Data) {
        $result.Data | ForEach-Object {
            $updateListBox.Items.Add("Security | $($_.Title) | $($_.KB)") | Out-Null
        }
         $statusLabel.Text = "Security updates loaded ($($updateListBox.Items.Count) found)."
    } elseif ($result.Success) {
         $statusLabel.Text = "No security updates found."
    }
})
$tabUpdates.Controls.Add($loadSecurityButton)

# --- Load Driver Updates Button ---
$loadDriverButton = New-Object System.Windows.Forms.Button
$loadDriverButton.Text = "Load Driver Updates"
$loadDriverButton.Size = New-Object System.Drawing.Size(180, 30)
$loadDriverButton.Location = New-Object System.Drawing.Point(220, 550)
$loadDriverButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$loadDriverButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$loadDriverButton.Add_Click({
    $updateListBox.Items.Clear() # Clear list before loading

     $result = Invoke-UpdateAction `
        -Action { Get-WindowsUpdate -Criteria "IsInstalled=0 and IsHidden=0" -IgnoreUserInput -Verbose } `
        -StatusStartMessage "Loading driver updates..." `
        -StatusSuccessMessage "Driver updates loaded." `
        -StatusFailMessage "Error loading driver updates."

    # --- Filter results AFTER Invoke-UpdateAction for Drivers ---
if ($result.Success -and $result.Data) {
    # Filter the results for items that are likely drivers
    # Drivers often have 'Driver' in CategoryNames or specific providers
    # Note: This filtering might need refinement based on actual data properties
    $driverUpdates = $result.Data | Where-Object {
        ($_.Categories -match 'Drivers') -or ($_.Title -match 'Driver')
        # Add other potential driver indicators if needed
    }

    if ($driverUpdates) {
        $driverUpdates | ForEach-Object {
            $updateListBox.Items.Add("Driver | $($_.Title) | $($_.KB)") | Out-Null
        }
        <span class="math-inline">statusLabel\.Text \= "Driver updates loaded \(</span>($updateListBox.Items.Count) found)."
    } else {
         $statusLabel.Text = "No specific Driver updates found in the results."
         $updateListBox.Items.Add("--- (No items matched Driver filter) ---") | Out-Null
    }
} elseif ($result.Success) {
     $statusLabel.Text = "No applicable updates found (broad criteria)."
}
# Error case is handled by Invoke-UpdateAction
# --- End of modified result handling ---
})
$tabUpdates.Controls.Add($loadDriverButton)

# --- Install Selected Updates Button ---
$installButton = New-Object System.Windows.Forms.Button
$installButton.Text = "Install Selected Updates"
$installButton.Size = New-Object System.Drawing.Size(180, 30)
$installButton.Location = New-Object System.Drawing.Point(420, 550)
$installButton.BackColor = [System.Drawing.Color]::FromArgb(29, 205, 159)
$installButton.ForeColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$installButton.Add_Click({
    $selectedItems = $updateListBox.SelectedItems
    if ($selectedItems.Count -eq 0) {
        [System.Windows.Forms.MessageBox]::Show("Please select updates to install from the list.", "Info", 'OK', 'Information')
        return
    }

    # Extract KB numbers or unique identifiers from selected items
    $kbsToInstall = $selectedItems | ForEach-Object {
        $parts = $_ -split '\|'
        if ($parts.Count -ge 3) {
             return $parts[2].Trim() # Assuming KB is the unique part
        }
        Write-Warning "Could not parse update information for: $_"
        return $null
    } | Where-Object { $_ -ne $null } | Select-Object -Unique

     if ($kbsToInstall.Count -eq 0) {
        [System.Windows.Forms.MessageBox]::Show("Could not identify valid updates to install from selection.", "Error", 'OK', 'Error')
        return
    }

    # Define the action for installing updates
    $installAction = {
        param($KBs)

        Write-Host "Attempting to install updates for KBs: $($KBs -join ', ')"
        # Important: Get the *current* update objects matching the KBs again before installing
        $allUpdates = Get-WindowsUpdate -IgnoreUserInput # Get all available non-installed updates
        $updatesToInstall = $allUpdates | Where-Object { $KBs -contains $_.KB }

        if ($updatesToInstall) {
             Write-Host "Found $($updatesToInstall.Count) matching update objects. Installing..."
             # Install the filtered updates
             # NOTE: Consider adding -Confirm:$false if you don't want any potential prompts
             Install-WindowsUpdate -Update $updatesToInstall -AcceptAll -IgnoreReboot -ErrorAction Stop
             Write-Host "Install-WindowsUpdate command completed for selected KBs."
             # Return $true or some status if needed, though not strictly necessary here
             return $true
        } else {
            Write-Warning "Could not find matching installable updates for selected KBs when re-querying."
            # Throw an error to be caught by Invoke-UpdateAction
            throw "Could not find matching installable updates for selected KBs: $($KBs -join ', ')"
        }
    }

    # Execute the install action
    $result = Invoke-UpdateAction `
        -Action $installAction `
        -ActionParameter $kbsToInstall `
        -StatusStartMessage "Installing $($kbsToInstall.Count) update(s)..." `
        -StatusSuccessMessage "Update installation process finished." `
        -StatusFailMessage "Error during update installation."

    if ($result.Success) {
        [System.Windows.Forms.MessageBox]::Show("Selected updates installed. A reboot may be required.", "Installation Complete", 'OK', 'Information')
        # Optional: Refresh list or clear selection after install
        $updateListBox.Items.Clear()
        $statusLabel.Text = "Installation complete. Load updates again to check status."
    }
    # Error message box is handled within Invoke-UpdateAction's catch block
})
$tabUpdates.Controls.Add($installButton)

# --- Add the Tab to the TabControl ---
# Ensure this line exists after defining all controls for $tabUpdates
# $tabControl.TabPages.Add($tabUpdates) # This should happen later when adding ALL tabs
# ============================================
# Finalize Tabs and Run (with color palette applied)
# ============================================

$tabControl.TabPages.AddRange(@(
    $tabSystemInfo,
    $tabPerformance,
    $tabStartup,
    $tabUpdates
))

# Add Progress Bar
$progressBar = New-Object System.Windows.Forms.ProgressBar
$progressBar.Style = 'Blocks'
$progressBar.Location = New-Object System.Drawing.Point(10, 630)
$progressBar.Size = New-Object System.Drawing.Size(960, 20)
$form.Controls.Add($progressBar)

# Add Status Label
$statusLabel = New-Object System.Windows.Forms.Label
$statusLabel.Text = "Ready"
$statusLabel.Location = New-Object System.Drawing.Point(10, 610)
$statusLabel.Size = New-Object System.Drawing.Size(960, 20)
$statusLabel.ForeColor = [System.Drawing.Color]::FromArgb(22, 153, 118)
$statusLabel.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)
$form.Controls.Add($statusLabel)

# Apply color palette to form and tab control
$form.BackColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$tabControl.BackColor = [System.Drawing.Color]::FromArgb(34, 34, 34)

$form.Controls.Add($tabControl)
$form.Add_Shown({ $form.Activate() })
[System.Windows.Forms.Application]::Run($form)
